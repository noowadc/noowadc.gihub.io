---

layout: default
title: [CsStudy] CH02, CH03.
writer: Dawoon Cha
date : 2023-08-31
nav_order: 1001

---
# CH2, 3

# CH2 : 데이터

## 0과 1로 숫자를 표현하는 방법

### 정보 단위

- 비트 : 컴퓨터가 이해하는 가장 작은 정보 단위
    - 한 비트에 두 가지 정보
- 바이트 : 비트보다 한 단계 큰 단위 = 8비트
- kb : =1000 바이트
- mb : 1000kb
- gb : 1000mb
- tb = 1000gb
- 비트 - 바이트 - 키로바이트 = 메가바이트 = 기가바이트 - 테라바이트

### 이진법

- 이진법 :수학에서 0과 1만으로 숫자를 표현하는 방법(으로 표현한 수 → 이진수)
- 십진법 : 0부터 9까지의 숫자만으로 모든 수를 표현하는 방법(으로 표현한 수 → 십진수)
- 이진수의 음수 표현 : 2의 보수를 구해 이 값을 음수로 간주 : 어떤 수를 그보다 큰 2^n에서 뺸 값 (11(2)의 보수는 100(2)에서 11(2)을 뺸 01(2)) = (모든 0과 1을 뒤집고 그에 1을 더한 값)
    - 이진수의 음수와 양수를 구분하기 위해 컴퓨터에서 **플래그**를 사용
- 플래그 : 컴퓨터 내부에서 어떤 값을 다룰 때 부가 정보가 필요한 경우 플래그를 사용
- 십육진법 : 수가 15를 넘어 가는 시점에 자리 올림을 하는 숫자 표현 방식
    - 10 : A, 11 : B, 12 : C, 13 : D, 14 : E, 15 :  F
    - 이진수를 십육진수로, 십육진수를 이진수로 변환하기 쉽기에 십육진수 자주 사용
- 십육진수 → 이진수 : 십육진수를 이루고 있는 각각의 숫자를 이진수로 변환하고, 그것을 그대로 이어 붙이기
- 이진수 → 십육진수 : 이진수 숫자를 네 개씩 끊고, 끊어 준 네 개의 숫자를 하나의 십육진수로 변환한 뒤 그대로 이어 붙이기

## 0과 1로 문자를 표현하는 방식

## 문자 집합과 인코딩

### 문자 집합

- 컴퓨터가 인식하고 표현할 수 있는 문자의 모음
- 문자 인코딩 : 문자 집합에 속한 문자를 0과 1로 변환해 컴퓨터가 읽을 수 있게 하는 방법
- 문자 디코딩 : 인코딩 반대 과정, 즉 0과 1로 이루어진 문자코드를 사람이 이해할 수 있는 문자로 변환하는 과정

### 아스키 코드

- 아스키 : 초창기 문자 집합 중 하나
    - 아스키 문자 집합에 속한 문자들은 각각 7비트로 표현,  표현 가능 가짓 수 : 2^7개, 총 128가지 문자
- 아스키 코드 : 아스키 문자에 대응된 고유한 수
- 확장 아스키

### EUC-KR

- 한글 인코딩
    - 완성형 인코딩 : 초성, 중성, 종성의 조합으로 이루어진 완성된 하나의 글자에 고우한 코드를 부여하는 인코딩 방식
    - 조합형 인코딩 : 초성을 위한 비트열, 중성을 위한 비트열, 종성을 위한 비트열을 할당하여 그것들의 조합으로 하나의 글자 코드를 완성하는 인코딩 방식
- KS X 1001, KS X 1003이라는 문자 집합을 기반으로 하는 대표적인 완성형 인코딩 방식
- EUC-KR로 인코딩된 한글 한 글자를 표현하려면 16비트가 필요, 16비트는 십육진수로 표현 가능
- EUC-KR의 문제를 해결하기 위해 등장한 CP949

### 유니코드와 UTF-8

- 유니코드 : 모든 언어를 아우르는 문자 집합과 통일된 표준 인코딩 방식
- EUC-KR보다 훨씬 다양한 한글을 포함
- UTF-8
    - 1바이트부터 4바이트까지 인코딩 결과를 만들어 냄
    - 인코딩 결과의 바이트는 유니코드의 문자에 부여된 값의 범위에 달라짐

# CH3 : 명령어

## 소스 코드와 명령어

### 고급언어와 저급 언어

- 고급 언어 : 사람을 위한 언어, 대부분의 프로그래밍 언어
- 저급 언어  컴퓨터가 직접 이해하고 실행할 수 잇는 언어
    - **명령어**로 이루어 짐
    - 고급언어로 작성된 소스 코드가 실행되려면 반드시 저급 언어, 즉 명령어로 변환되어야 함
    - 기계어 : 0과 1의 명령어 비트로 이루어진 단어, 0과 1로 이루어진 명령어 모음
    - 어셈블리어 : 기계어가 오로지 컴퓨터만을 위해 만들어져서 사람이 이해하기 쉽지 않은 문제가 발생해 이를 해결하려는 언어
        - 명령어를 읽기 편한한 형태로 번역한 언어

### 컴파일 언어와 인터프리터 언어

- 컴파일 언어 : 컴파일러에 의해 소스 코드 전체가 저급 언어로 변환되어 실행되는 고급 언어
    - 컴파일 : 소스 코드 전체가 저급 언어로 변환되는 과정
    - 컴파일러 : 이를 수행해 주는 도구
    - 목적 코드 : 컴파일이 성공적으로 수행되면 개발자가 작성한 소스 코드는 컴퓨터가 이해할 수 있는 저급 언어로 변환된 코드
- 인터프리터 언어 : 인터프리터에 의해 소스 코드가 한 줄씩 실행되는 고급 언어 (python)
    - 인터프리터 : 소스 코드를 한 줄씩 차례로 실행하는데 이를 돕는 도구
    - 컴파일 언어와 달리 소스 코드 전체를 변환하는 시간을 기다릴 필요가 없음
    - 컴파일 언어와 달리 N번째 줄에 오류가 있어도 그 전까지 작동 잘 됨
    - 컴파일 언어보다 느림

### 목적파일과 실행파일

- 목적 파일 : 목적 코드로 이루어진 파일
- 실행 파일 : 실행 코드로 이루어진 파일
    - ex) .exe 확장자를 가짐
- 링킹 : 목적 코드가 실행 파일이 되기 위한 작업
    - ‘HELPER_더하기’기능과 ‘화면_출력’ 기능을 ‘main.o’와 연결 짓는 작업

## 명령어의 구조

### 연산 코드와 오퍼랜드

- 명령어 : 연산코드와 오퍼랜드로 구성되어 있음
- 연산 코드 : 명령어가 수행할 연산 (연산자)
    - 데이터 전송
        - MOVE : 데이터를 옮겨라
        - STORE : 메모리에 저장하라
        - LOAD : 메모리에서 CPU로 데이터를 가져와라
        - PUSH : 스택에 데이터를 저장하라
        - POP : 스택의 최상단 데이터를 가져와라
    - 산술/논리 연산
        - ADD / SUBSTRACT / MULTIPLY / DIVIDE : 덧셈 / 뺄셈 / 곱셈 / 나눗셈을 수행하라
        - INCREMENT / DECREMENT : 오퍼랜드에 1을 더하라 / 빼라
        - AND / OR / NOT : AND / OR / NOT 연산을 수행하라
        - COMPARE : 두 개의 숫자 또는 true / false 값을 비교하라
    - 제어 흐름 변경
        - JUMP : 특정 주소로 실행 순서를 옮겨라
        - CONDITIONAL JUMP : 조건에 부합할 때 특정 주소로 실행 순서를 옮겨라
        - HALT : 프로그램의 실행을 멈춰라
        - CALL : 되돌아올 주소를 저장한 채 특정 주소로 실행 순서를 옮겨라
        - RETURN : CALL을 호출할 때 저장했던 주소로 돌아가라
    - 입출력 제어
        - READ (INPUT): 특정 입출력 장치로부터 데이터를 읽어라
        - WRITE(OUTPUT): 특정 입출력 장치로 데이터를 써라
        - START IO: 입출력 장치를 시작하라
        - TEST IO: 입출력 장치의 상태를 확인하라
- 오퍼랜드 : 연산에 사용할 데이터 또는 연산에 사용할 데이터가 저장된 위치(피연산자)
    - 오퍼랜드 필드 → 주소 필드
    - 0-주소 명령어 : 오퍼랜드가 하나도 없는 명령어
    - 1-주소 명령어 : 오퍼랜드 1
    - 2-주소 명령어 : 오퍼랜드 2
    - 3-주소 명령어 : 오퍼랜드 3

### 주소 지정 방식

- 유효 주소 : 연산 코드에 사용할 데이터가 저장된 위치, 즉 연산의 대상이 되는 데이터가 저장된 위치
- 주소 지정 방식 : 오퍼랜드 필드에 데이터가 저장된 위치를 명시할 때 연산에 사용할 데이터 위치를 찾는 방법
    - 즉시 주소 지정 방식 : 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시하는 방식
        - 단점 : 표현할 수 있는 데이터의 크기가 작아진다.
        - 장점 : 연산에 사용할 데이터를 메모리나 레지스터로부터 찾는 과정이 없어 빠르다.
    - 직접 주소 지정 방식 : 오퍼랜드 필드에 유효 주소를 직접적으로 명시하는 방식
        - 즉시 주소 지정 방식보다 표현할 수 있는 데이터의 크기가 더 크다.
        - 유효 주소를 표현할 수 있는 범위가 연산코드의 비트 수만큼 줄어들었다.

### 스택과 큐

- 스택 : 한쪽 끝이 막혀 있는 통과 같은 저장 공간
    - 한쪽 끝이 막혀 있어서 막혀있지 않은 쪽으로 데이터를 차곡차곡 저장하고 저장한 자료를 빼낼 때는 마지막으로 저장한 데이터부터 빼냅 니다.
    - LIFO
    - PUSH : 스택에 새로운 데이터를 저장하는 명령어
    - POP : 스택에 저장된 데이터를 꺼내는 명령어
- 큐 : 스택과는 달리 양쪽이 뚫려 있는 통과 같은 저장 공간
    - 큐는 한쪽으로는 데이터 를 저장하고, 다른 한쪽으로는 먼저 저장한 순서대로 데이터를 빼냅니다
    - FIFO
